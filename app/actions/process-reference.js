'use server';
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessingStage = void 0;
exports.extractYouTubeMetadata = extractYouTubeMetadata;
exports.processReferenceContent = processReferenceContent;
const gemini_service_1 = require("@/lib/gemini-service");
const auth_1 = require("@/lib/auth");
const youtube_transcript_1 = require("@/lib/youtube-transcript");
const performance_monitor_1 = require("@/lib/performance-monitor");
const error_utils_1 = require("@/lib/error-utils");
const logger_1 = require("@/lib/logger");
const content_complexity_analyzer_1 = require("@/lib/content-complexity-analyzer");
const adaptive_content_processor_1 = require("@/lib/adaptive-content-processor");
const token_allocation_manager_1 = require("@/lib/token-allocation-manager");
const json_parser_simplified_1 = require("@/lib/json-parser-simplified");
const structured_output_service_1 = require("@/lib/structured-output-service");
const gemini_direct_1 = require("@/lib/gemini-direct");
const youtube_processing_service_1 = require("@/lib/youtube-processing-service");
// Add timeout configuration for external APIs
const API_TIMEOUT = 30000; // 30 seconds
// Simple in-memory cache for development (use Redis in production)
const contentCache = new Map();
const CACHE_TTL = 3600000; // 1 hour in milliseconds
// Helper function to get proper language display name
function getLanguageDisplayName(language) {
    const languageMap = {
        'ÁπÅÈ´î‰∏≠Êñá': 'Traditional Chinese',
        'ÁÆÄ‰Ωì‰∏≠Êñá': 'Simplified Chinese',
        'English': 'English',
        'zh-TW': 'Traditional Chinese',
        'zh-CN': 'Simplified Chinese',
        'en-US': 'English'
    };
    return languageMap[language || ''] || 'English';
}
// Processing stage definitions
var ProcessingStage;
(function (ProcessingStage) {
    ProcessingStage["YOUTUBE_METADATA"] = "YouTube\u5143\u6578\u64DA\u63D0\u53D6";
    ProcessingStage["VIDEO_ANALYSIS"] = "\u8996\u983B\u5167\u5BB9\u5206\u6790";
    ProcessingStage["CONTENT_PROCESSING"] = "\u5167\u5BB9\u8655\u7406";
    ProcessingStage["STRUCTURED_GENERATION"] = "\u7D50\u69CB\u5316\u751F\u6210";
    ProcessingStage["GEMINI_TEXT_GENERATION"] = "Gemini\u6587\u5B57\u751F\u6210";
    ProcessingStage["JSON_PARSING"] = "JSON\u89E3\u6790";
    ProcessingStage["CHARACTERS_GENERATION"] = "\u89D2\u8272\u751F\u6210";
    ProcessingStage["SCENES_GENERATION"] = "\u5834\u666F\u751F\u6210";
    ProcessingStage["FINAL_PITCH_COMPILATION"] = "\u6700\u7D42pitch\u7DE8\u8B6F";
})(ProcessingStage || (exports.ProcessingStage = ProcessingStage = {}));
async function extractYouTubeMetadata(url) {
    return performance_monitor_1.performanceMonitor.trackOperation('youtube_metadata_extraction', async () => {
        try {
            console.log('üöÄ Starting YouTube metadata extraction with enhanced service');
            // Initialize enhanced processing service
            const processingService = new youtube_processing_service_1.YouTubeProcessingService();
            // Use the enhanced service for processing - supports both shorts and regular videos
            const isShorts = /youtube\.com\/shorts\//.test(url);
            console.log(`Processing URL: ${url} (${isShorts ? 'Shorts' : 'Video'} detected)`);
            const result = await processingService.processYouTubeContent(url, isShorts ? 'shorts' : 'auto');
            console.log(`‚úÖ Processing complete. Strategy: ${result.processingStrategy}, Confidence: ${result.confidence}`);
            if (result.error) {
                console.error('‚ùå Processing service returned error:', result.error);
                throw new Error(result.error);
            }
            // Convert ProcessingResult to ReferenceSource format
            const referenceSource = {
                title: result.title,
                description: result.description,
                duration: result.duration,
                thumbnail: result.thumbnail,
                // üé• ‰ΩøÁî®Ë¶ñÈ†ªÂàÜÊûêÁöÑËÖ≥Êú¨ÔºàÂ¶ÇÊûúÊúâÁöÑË©±Ôºâ
                transcript: result.transcript || result.description,
                processingStatus: 'completed',
                // üéØ ‰øùÁïôË¶ñÈ†ªÂàÜÊûêÊï∏Êìö‰ª•Áî®ÊñºËßíËâ≤ÊèèËø∞
                videoAnalysis: result.videoAnalysis,
                hasVideoAnalysis: result.hasVideoAnalysis,
                videoAnalysisQuality: result.videoAnalysisQuality
            };
            // üß† ÂàÜÊûêÂÖßÂÆπË§áÈõúÂ∫¶
            if (referenceSource.videoAnalysis || referenceSource.transcript) {
                console.log('üîç Analyzing content complexity...');
                referenceSource.complexityMetrics = content_complexity_analyzer_1.contentComplexityAnalyzer.analyzeComplexity(referenceSource.videoAnalysis, referenceSource);
                console.log(`üìä Content complexity: ${referenceSource.complexityMetrics.level} (score: ${referenceSource.complexityMetrics.totalScore})`);
            }
            console.log('üéØ Converted to ReferenceSource format:', {
                title: referenceSource.title?.substring(0, 50) + '...',
                hasDescription: !!referenceSource.description,
                hasTranscript: !!referenceSource.transcript,
                duration: referenceSource.duration,
                hasVideoAnalysis: !!referenceSource.hasVideoAnalysis,
                videoAnalysisQuality: referenceSource.videoAnalysisQuality,
                charactersFound: referenceSource.videoAnalysis?.characters?.length || 0,
                scenesFound: referenceSource.videoAnalysis?.sceneBreakdown?.length || 0
            });
            return referenceSource;
            // This code block is now replaced by the enhanced service above
        }
        catch (error) {
            console.error('‚ùå Enhanced YouTube processing failed:', error);
            logger_1.logger.error('Error extracting YouTube metadata with enhanced service', error);
            // Provide user-friendly error message based on error type
            let errorMessage = 'Failed to process YouTube content';
            if (error instanceof Error) {
                if (error.message.includes('quota exceeded')) {
                    errorMessage = 'YouTube API quota exceeded. Please try again later.';
                }
                else if (error.message.includes('not found')) {
                    errorMessage = 'Video not found or not accessible. Please check the URL.';
                }
                else if (error.message.includes('API key')) {
                    errorMessage = 'YouTube API configuration error. Please contact support.';
                }
                else if (error.message.includes('temporarily unavailable')) {
                    errorMessage = 'Service temporarily unavailable. Please try again in a few moments.';
                }
                else {
                    errorMessage = error.message;
                }
            }
            return {
                processingStatus: 'error',
                errorMessage
            };
        }
    }, { url });
}
async function processReferenceContent(source, targetStyle, targetLanguage, useStructuredOutput) {
    return await performance_monitor_1.performanceMonitor.trackOperation('reference_content_processing', async () => {
        const startTime = Date.now();
        try {
            console.log('Processing reference content with enhanced Gemini service');
            console.log('Source type:', source.type);
            console.log('Has transcript:', !!source.transcript);
            console.log('Description length:', source.description?.length || 0);
            console.log('Has video analysis:', !!source.hasVideoAnalysis);
            console.log('Video analysis quality:', source.videoAnalysisQuality);
            console.log('Characters in analysis:', source.videoAnalysis?.characters?.length || 0);
            console.log('Scenes in analysis:', source.videoAnalysis?.sceneBreakdown?.length || 0);
            // First, check Gemini service health
            const healthStatus = await (0, gemini_service_1.checkGeminiHealth)();
            console.log('Gemini Health Check:', healthStatus);
            if (!healthStatus.healthy) {
                console.warn('Gemini service is not healthy, proceeding with fallback approach');
            }
            // Check cache for identical processing requests
            const cacheKey = `processed_content_${generateContentHash(source, targetStyle, targetLanguage)}`;
            const cached = getCachedContent(cacheKey);
            if (cached) {
                console.log('Using cached processed content');
                return cached;
            }
            // Determine content quality level with improved logic
            let contentQuality = 'full';
            let warning;
            let content = '';
            // üß† Use adaptive content processing based on complexity
            let processedContent;
            let complexityMetrics;
            if (source.complexityMetrics) {
                console.log('üîÑ Using existing complexity metrics');
                complexityMetrics = source.complexityMetrics;
            }
            else {
                console.log('üîç Analyzing content complexity for processing...');
                complexityMetrics = content_complexity_analyzer_1.contentComplexityAnalyzer.analyzeComplexity(source.videoAnalysis, source);
            }
            console.log('üìä Processing with complexity-based strategy:', {
                level: complexityMetrics.level,
                score: complexityMetrics.totalScore,
                tokenBudget: complexityMetrics.recommendedTokenBudget,
                useStructuredOutput: complexityMetrics.shouldUseStructuredOutput
            });
            // ‰ΩøÁî®ÈÅ©ÊáâÊÄßÂÖßÂÆπËôïÁêÜ
            processedContent = adaptive_content_processor_1.adaptiveContentProcessor.processContent(source, complexityMetrics);
            content = processedContent.content;
            contentQuality = processedContent.contentQuality;
            warning = processedContent.warning;
            console.log(`üéØ Adaptive processing completed: ${processedContent.processingStrategy}`);
            console.log(`   - Content length: ${content.length}`);
            console.log(`   - Token estimate: ${processedContent.tokenEstimate}`);
            console.log(`   - Simplification applied: ${processedContent.simplificationApplied}`);
            // Validate content length to avoid excessive processing time
            if (content.length > 50000) {
                console.log('Content too long, truncating for optimal processing');
                content = content.substring(0, 50000) + '\n\n[Content truncated for processing efficiency]';
                warning = (warning || '') + ' Content was truncated due to length for optimal processing.';
            }
            // For text input, always use full quality
            if (source.type === 'text_input') {
                content = source.transcript || source.description || '';
                contentQuality = 'full';
                warning = undefined;
            }
            // üéØ Use new token allocation system based on complexity
            const tokenAllocation = useStructuredOutput && complexityMetrics.shouldUseStructuredOutput
                ? token_allocation_manager_1.tokenAllocationManager.allocateForStructuredOutput(complexityMetrics)
                : token_allocation_manager_1.tokenAllocationManager.allocateForStandardOutput(complexityMetrics);
            console.log('Token Allocation Analysis:', {
                level: complexityMetrics.level,
                totalScore: complexityMetrics.totalScore,
                tokenAllocation: tokenAllocation.maxTokens,
                temperature: tokenAllocation.temperature,
                timeout: tokenAllocation.timeout,
                reasoning: tokenAllocation.reasoning,
                useStructuredOutput: complexityMetrics.shouldUseStructuredOutput && useStructuredOutput
            });
            // Check if we should use structured output (Traditional Chinese) and complexity allows
            if (useStructuredOutput && complexityMetrics.shouldUseStructuredOutput && (targetLanguage === 'ÁπÅÈ´î‰∏≠Êñá' || targetLanguage === 'Traditional Chinese' || targetLanguage === 'zh-TW')) {
                console.log('üèóÔ∏è Using enhanced structured output system for Traditional Chinese generation');
                let structuredAttempts = 0;
                const maxStructuredAttempts = 3;
                while (structuredAttempts < maxStructuredAttempts) {
                    structuredAttempts++;
                    console.log(`üîÑ Structured output attempt ${structuredAttempts}/${maxStructuredAttempts}`);
                    try {
                        // Create instance of GeminiDirectService
                        const geminiDirect = new gemini_direct_1.GeminiDirectService();
                        const structuredService = new structured_output_service_1.StructuredOutputService(geminiDirect);
                        const structuredPitch = await structuredService.generateStructuredPitch(content, contentQuality);
                        if (structuredPitch && structuredPitch.finalPitch && structuredPitch.finalPitch.length > 50) {
                            console.log('‚úÖ Structured output generation successful!');
                            const referenceContent = {
                                id: generateId(),
                                source: {
                                    ...source,
                                    processingStatus: 'completed'
                                },
                                extractedContent: {
                                    title: source.title || 'Untitled',
                                    description: source.description || '',
                                    transcript: source.transcript || '',
                                    keyTopics: structuredPitch.tags || structuredPitch.characters.map(c => c.name),
                                    sentiment: 'positive',
                                    duration: source.duration || 0
                                },
                                generatedPitch: structuredPitch.finalPitch,
                                contentQuality,
                                warning: warning ? warning + ' [Enhanced structured output]' : '[Enhanced structured output]',
                                createdAt: new Date(),
                                updatedAt: new Date(),
                                // Structured output specific fields
                                structuredPitch: structuredPitch,
                                isStructuredOutput: true
                            };
                            // Cache the processed result
                            setCachedContent(cacheKey, referenceContent);
                            const processingTime = Date.now() - startTime;
                            console.log(`Structured content processing completed in ${processingTime}ms`);
                            return referenceContent;
                        }
                        else {
                            console.log(`‚ö†Ô∏è Structured output attempt ${structuredAttempts} returned incomplete result`);
                            if (structuredAttempts === maxStructuredAttempts) {
                                console.log('üîÑ All structured attempts failed');
                                return {
                                    id: generateId(),
                                    source: {
                                        ...source,
                                        processingStatus: 'error',
                                        processingError: {
                                            stage: ProcessingStage.STRUCTURED_GENERATION,
                                            message: `${maxStructuredAttempts}Ê¨°ÁµêÊßãÂåñÂòóË©¶ÂæåÂ§±Êïó`,
                                            originalContent: content
                                        }
                                    },
                                    extractedContent: {
                                        title: source.title || 'Untitled',
                                        description: source.description || '',
                                        transcript: source.transcript || '',
                                        keyTopics: [],
                                        sentiment: 'positive',
                                        duration: source.duration || 0
                                    },
                                    generatedPitch: `ËôïÁêÜÈöéÊÆµÂ§±ÊïóÔºö${ProcessingStage.STRUCTURED_GENERATION}\n\nÂéüÂõ†Ôºö${maxStructuredAttempts}Ê¨°ÁµêÊßãÂåñÂòóË©¶ÂæåÂ§±Êïó\n\nÂéüÂßãÂÖßÂÆπÔºö\n${content}`,
                                    contentQuality,
                                    warning: `Âú® ${ProcessingStage.STRUCTURED_GENERATION} ÈöéÊÆµÂ§±ÊïóÔºö${maxStructuredAttempts}Ê¨°ÁµêÊßãÂåñÂòóË©¶ÂæåÂ§±Êïó`,
                                    processingError: {
                                        stage: ProcessingStage.STRUCTURED_GENERATION,
                                        message: `${maxStructuredAttempts}Ê¨°ÁµêÊßãÂåñÂòóË©¶ÂæåÂ§±Êïó`,
                                        originalContent: content
                                    },
                                    createdAt: new Date(),
                                    updatedAt: new Date(),
                                    isStructuredOutput: false
                                };
                            }
                            // Wait before retry
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                    }
                    catch (structuredError) {
                        console.log(`‚ùå Structured output attempt ${structuredAttempts} error:`, structuredError);
                        if (structuredAttempts === maxStructuredAttempts) {
                            console.log('üîÑ All structured attempts failed');
                            return {
                                id: generateId(),
                                source: {
                                    ...source,
                                    processingStatus: 'error',
                                    processingError: {
                                        stage: ProcessingStage.STRUCTURED_GENERATION,
                                        message: `ÁµêÊßãÂåñÁîüÊàêÈåØË™§Ôºö${structuredError instanceof Error ? structuredError.message : String(structuredError)}`,
                                        originalContent: content
                                    }
                                },
                                extractedContent: {
                                    title: source.title || 'Untitled',
                                    description: source.description || '',
                                    transcript: source.transcript || '',
                                    keyTopics: [],
                                    sentiment: 'positive',
                                    duration: source.duration || 0
                                },
                                generatedPitch: `ËôïÁêÜÈöéÊÆµÂ§±ÊïóÔºö${ProcessingStage.STRUCTURED_GENERATION}\n\nÂéüÂõ†ÔºöÁµêÊßãÂåñÁîüÊàêÈåØË™§\nÈåØË™§Ë©≥ÊÉÖÔºö${structuredError instanceof Error ? structuredError.message : String(structuredError)}\n\nÂéüÂßãÂÖßÂÆπÔºö\n${content}`,
                                contentQuality,
                                warning: `Âú® ${ProcessingStage.STRUCTURED_GENERATION} ÈöéÊÆµÂ§±ÊïóÔºöÁµêÊßãÂåñÁîüÊàêÈåØË™§`,
                                processingError: {
                                    stage: ProcessingStage.STRUCTURED_GENERATION,
                                    message: `ÁµêÊßãÂåñÁîüÊàêÈåØË™§Ôºö${structuredError instanceof Error ? structuredError.message : String(structuredError)}`,
                                    originalContent: content
                                },
                                createdAt: new Date(),
                                updatedAt: new Date(),
                                isStructuredOutput: false
                            };
                        }
                        // Wait before retry
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }
            }
            const contentQualityContext = contentQuality === 'full'
                ? 'You have access to the full transcript/content.'
                : contentQuality === 'partial'
                    ? 'You have access to the title, description, and enhanced metadata. Work with what is available to create the best possible pitch.'
                    : 'You have limited information (basic metadata only). Be creative but stay grounded in the available information and focus on what can be inferred from the title and description.';
            const basePrompt = `Create a video pitch based on this content. CRITICAL: Return ONLY pure JSON without any markdown formatting, code blocks, or backticks.

Title: ${source.title || 'Untitled'}
Content: ${content}
Type: ${(source.duration || 0) <= 60 ? 'YouTube Shorts (viral, 15-60s)' : 'Standard Video'}

Create a detailed story pitch for ${getLanguageDisplayName(targetLanguage)} audience. Even with limited info, be creative and elaborate.

Return EXACTLY this JSON structure (no \`\`\`json, no backticks, PURE JSON ONLY):
{
  "analysis": {
    "keyTopics": ["topic1", "topic2", "topic3"],
    "sentiment": "positive",
    "coreMessage": "Brief core message",
    "targetAudience": "Target demographic"
  },
  "generatedPitch": "Detailed video pitch with characters, story, scenes, emotions. Minimum 200 words in ${getLanguageDisplayName(targetLanguage)}.",
  "rationale": "Why this pitch works"
}`;
            // Generate base prompt for standard processing
            const optimizedPrompt = basePrompt; // Use the base prompt directly
            // Use the adaptive token allocation with retry logic
            let text;
            let attempts = 0;
            const maxAttempts = 3;
            let currentTokenAllocation = tokenAllocation;
            while (attempts < maxAttempts && !text) {
                attempts++;
                console.log(`üîÑ Gemini generation attempt ${attempts}/${maxAttempts}`);
                console.log(`   - Tokens: ${currentTokenAllocation.maxTokens}`);
                console.log(`   - Temperature: ${currentTokenAllocation.temperature}`);
                try {
                    const response = await (0, gemini_service_1.generateTextWithGemini)(optimizedPrompt, {
                        temperature: currentTokenAllocation.temperature,
                        maxTokens: currentTokenAllocation.maxTokens,
                        timeout: currentTokenAllocation.timeout
                    });
                    if (response && response.trim().length > 0) {
                        text = response;
                        console.log(`‚úÖ Gemini generation successful on attempt ${attempts}`);
                    }
                    else {
                        console.log(`‚ö†Ô∏è Attempt ${attempts}: Empty response from Gemini`);
                    }
                }
                catch (geminiError) {
                    console.log(`‚ùå Attempt ${attempts} failed:`, geminiError);
                    // Check if it's a token limit issue
                    const errorMessage = geminiError instanceof Error ? geminiError.message : String(geminiError);
                    const isTokenIssue = errorMessage.includes('MAX_TOKENS') || errorMessage.includes('token limit');
                    if (isTokenIssue && attempts < maxAttempts) {
                        // Adjust token allocation for next attempt
                        currentTokenAllocation = token_allocation_manager_1.tokenAllocationManager.adjustAllocation(currentTokenAllocation, {
                            wasTokenLimitHit: true,
                            finishReason: 'MAX_TOKENS',
                            isStructuredOutput: false
                        });
                        console.log(`üîß Adjusted tokens to ${currentTokenAllocation.maxTokens} for next attempt`);
                    }
                    if (attempts === maxAttempts) {
                        console.log('‚ùå All Gemini attempts failed, using enhanced fallback');
                    }
                }
            }
            if (!text || text.trim().length === 0) {
                console.log('‚ùå All Gemini generation attempts failed');
                return {
                    id: generateId(),
                    source: {
                        ...source,
                        processingStatus: 'error',
                        processingError: {
                            stage: ProcessingStage.GEMINI_TEXT_GENERATION,
                            message: `${attempts}Ê¨°ÂòóË©¶ÂæåÁîüÊàêÂ§±Êïó`,
                            originalContent: content
                        }
                    },
                    extractedContent: {
                        title: source.title || 'Untitled',
                        description: source.description || '',
                        transcript: source.transcript || '',
                        keyTopics: extractKeywordsFromContent(content),
                        sentiment: 'positive',
                        duration: source.duration || 0
                    },
                    generatedPitch: `ËôïÁêÜÈöéÊÆµÂ§±ÊïóÔºö${ProcessingStage.GEMINI_TEXT_GENERATION}\n\nÂéüÂõ†Ôºö${attempts}Ê¨°ÂòóË©¶ÂæåÁîüÊàêÂ§±Êïó\n\nÂéüÂßãÂÖßÂÆπÔºö\n${content}`,
                    contentQuality,
                    warning: `Âú® ${ProcessingStage.GEMINI_TEXT_GENERATION} ÈöéÊÆµÂ§±ÊïóÔºö${attempts}Ê¨°ÂòóË©¶ÂæåÁîüÊàêÂ§±Êïó`,
                    processingError: {
                        stage: ProcessingStage.GEMINI_TEXT_GENERATION,
                        message: `${attempts}Ê¨°ÂòóË©¶ÂæåÁîüÊàêÂ§±Êïó`,
                        originalContent: content
                    },
                    createdAt: new Date(),
                    updatedAt: new Date()
                };
            }
            // Enhanced JSON parsing using new intelligent parser (Solution 1 + 5)
            console.log('üîß Starting enhanced JSON parsing for AI response');
            console.log('Raw AI response length:', text.length);
            console.log('First 200 chars:', text.substring(0, 200));
            // Use the new enhanced JSON parser
            const parseResult = (0, json_parser_simplified_1.parseAiJsonResponse)(text);
            let result;
            if (parseResult.success && parseResult.data) {
                console.log('‚úÖ Enhanced JSON parsing successful!');
                console.log('Repair attempts:', parseResult.repairAttempts?.length || 0);
                console.log('Parse time:', parseResult.parseTime + 'ms');
                result = parseResult.data;
            }
            else {
                // Check if Gemini actually returned content
                console.log('‚ö†Ô∏è JSON parsing failed, checking raw response...');
                console.log('Parse errors:', parseResult.repairAttempts);
                // Try one more time with a simpler extraction
                const simplePitchMatch = text.match(/"generatedPitch"\s*:\s*"([\s\S]+?)"/);
                if (simplePitchMatch && simplePitchMatch[1] && simplePitchMatch[1].length > 100) {
                    console.log('‚úÖ Found pitch content using simple extraction');
                    result = {
                        generatedPitch: simplePitchMatch[1].replace(/\\n/g, '\n').replace(/\\"/g, '"'),
                        analysis: {
                            keyTopics: extractKeywordsFromContent(content),
                            sentiment: 'positive',
                            coreMessage: `Content analysis for: ${source.title}`,
                            targetAudience: 'Social media users, entertainment seekers'
                        },
                        rationale: 'Extracted using simple pattern matching after JSON parse failure'
                    };
                }
                else {
                    // No valid content found - return parsing failure
                    console.log('‚ùå No valid pitch content found');
                    return {
                        id: generateId(),
                        source: {
                            ...source,
                            processingStatus: 'error',
                            processingError: {
                                stage: ProcessingStage.JSON_PARSING,
                                message: 'JSONËß£ÊûêÂ§±ÊïóÔºåÁÑ°Ê≥ïÊèêÂèñÊúâÊïàÂÖßÂÆπ',
                                originalContent: text
                            }
                        },
                        extractedContent: {
                            title: source.title || 'Untitled',
                            description: source.description || '',
                            transcript: source.transcript || '',
                            keyTopics: extractKeywordsFromContent(content),
                            sentiment: 'positive',
                            duration: source.duration || 0
                        },
                        generatedPitch: `ËôïÁêÜÈöéÊÆµÂ§±ÊïóÔºö${ProcessingStage.JSON_PARSING}\n\nÂéüÂõ†ÔºöJSONËß£ÊûêÂ§±ÊïóÔºåÁÑ°Ê≥ïÊèêÂèñÊúâÊïàÂÖßÂÆπ\n\nÂéüÂßãÂõûÊáâÔºö\n${text}`,
                        contentQuality,
                        warning: `Âú® ${ProcessingStage.JSON_PARSING} ÈöéÊÆµÂ§±ÊïóÔºöJSONËß£ÊûêÂ§±Êïó`,
                        processingError: {
                            stage: ProcessingStage.JSON_PARSING,
                            message: 'JSONËß£ÊûêÂ§±ÊïóÔºåÁÑ°Ê≥ïÊèêÂèñÊúâÊïàÂÖßÂÆπ',
                            originalContent: text
                        },
                        createdAt: new Date(),
                        updatedAt: new Date()
                    };
                }
            }
            // Additional validation for completeness
            if (!result.generatedPitch || result.generatedPitch.length < 50) {
                console.log('‚ö†Ô∏è Generated pitch too short, enhancing...');
                result.generatedPitch = createEnhancedFallbackPitch(source, targetStyle, targetLanguage, complexityMetrics);
                result.rationale = (result.rationale || '') + ' [Enhanced due to short pitch]';
            }
            const referenceContent = {
                id: generateId(),
                source: {
                    ...source,
                    processingStatus: 'completed'
                },
                extractedContent: {
                    title: source.title || 'Untitled',
                    description: source.description || '',
                    transcript: source.transcript || '',
                    keyTopics: result.analysis.keyTopics || [],
                    sentiment: result.analysis.sentiment || 'neutral',
                    duration: source.duration || 0
                },
                generatedPitch: result.generatedPitch,
                contentQuality,
                warning,
                createdAt: new Date(),
                updatedAt: new Date(),
                // Standard output fields
                isStructuredOutput: false
            };
            // Cache the processed result
            setCachedContent(cacheKey, referenceContent);
            const processingTime = Date.now() - startTime;
            console.log(`Content processing completed in ${processingTime}ms`);
            return referenceContent;
        }
        catch (error) {
            logger_1.logger.error('Error processing reference content', error, {
                additionalData: {
                    sourceType: source.type,
                    hasTranscript: !!source.transcript,
                    contentLength: (source.transcript || source.description || '').length,
                    targetStyle,
                    targetLanguage
                }
            });
            // Handle Gemini service errors with specific messaging
            if (error instanceof gemini_service_1.GeminiServiceError) {
                console.error('Gemini Service Error:', {
                    code: error.code,
                    isRetryable: error.isRetryable,
                    originalError: error.originalError?.message
                });
                // If it's a model availability issue, create fallback content
                if (error.code === 'NO_MODELS_AVAILABLE' || error.code === 'MODEL_UNAVAILABLE') {
                    console.log('Creating fallback content due to model unavailability');
                    const fallbackPitch = createFallbackPitch(source, targetStyle, targetLanguage);
                    return {
                        id: generateId(),
                        source: {
                            ...source,
                            processingStatus: 'error',
                            processingError: {
                                stage: ProcessingStage.GEMINI_TEXT_GENERATION,
                                message: 'Ê®°Âûã‰∏çÂèØÁî®',
                                originalContent: source.transcript || source.description || ''
                            }
                        },
                        extractedContent: {
                            title: source.title || 'Untitled',
                            description: source.description || '',
                            transcript: source.transcript || '',
                            keyTopics: extractKeywordsFromContent(source.transcript || source.description || ''),
                            sentiment: 'neutral',
                            duration: source.duration || 0
                        },
                        generatedPitch: `ËôïÁêÜÈöéÊÆµÂ§±ÊïóÔºö${ProcessingStage.GEMINI_TEXT_GENERATION}\n\nÂéüÂõ†ÔºöÊ®°Âûã‰∏çÂèØÁî®\n\nÂéüÂßãÂÖßÂÆπÔºö\n${source.transcript || source.description || source.title || 'ÁÑ°ÂèØÁî®ÂÖßÂÆπ'}`,
                        contentQuality: 'metadata-only',
                        warning: `Âú® ${ProcessingStage.GEMINI_TEXT_GENERATION} ÈöéÊÆµÂ§±ÊïóÔºöÊ®°Âûã‰∏çÂèØÁî®`,
                        processingError: {
                            stage: ProcessingStage.GEMINI_TEXT_GENERATION,
                            message: 'Ê®°Âûã‰∏çÂèØÁî®',
                            originalContent: source.transcript || source.description || ''
                        },
                        createdAt: new Date(),
                        updatedAt: new Date()
                    };
                }
                // For auth errors, provide specific guidance
                if (error.code === 'AUTH_ERROR') {
                    throw new Error('Authentication failed: Please ask your administrator to run "gcloud auth application-default login" to reauthenticate.');
                }
                throw new Error(`Gemini service error: ${error.message}`);
            }
            if (error instanceof auth_1.AuthenticationError) {
                throw error;
            }
            // Use the error translation utility for user-friendly messages
            const friendlyError = (0, error_utils_1.translateError)(error);
            throw new Error(`${friendlyError.title}: ${friendlyError.message}${friendlyError.actionable ? ` ${friendlyError.actionable}` : ''}`);
        }
    });
}
// Helper functions
function extractVideoId(url) {
    const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
        /youtube\.com\/v\/([^&\n?#]+)/,
        // Add support for YouTube Shorts URLs
        /youtube\.com\/shorts\/([^&\n?#]+)/,
        // Add support for live and mobile URLs
        /youtube\.com\/live\/([^&\n?#]+)/,
        /m\.youtube\.com\/watch\?v=([^&\n?#]+)/
    ];
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match && match[1]) {
            // Remove any additional query parameters from the video ID
            return match[1].split('?')[0];
        }
    }
    return null;
}
function parseDuration(duration) {
    // Convert ISO 8601 duration (PT4M13S) to seconds
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match)
        return 0;
    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');
    return hours * 3600 + minutes * 60 + seconds;
}
function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}
// Enhanced helper functions for performance optimization
/**
 * Fetch with timeout support
 */
async function fetchWithTimeout(url, timeout) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    try {
        const response = await fetch(url, {
            signal: controller.signal,
            headers: {
                'User-Agent': 'ViralCraft/1.0'
            }
        });
        clearTimeout(timeoutId);
        return response;
    }
    catch (error) {
        clearTimeout(timeoutId);
        if (error instanceof Error && error.name === 'AbortError') {
            throw new Error('Request timeout');
        }
        throw error;
    }
}
// Retry function removed - now handled by GeminiService
/**
 * Simple cache management
 */
function getCachedContent(key) {
    const cached = contentCache.get(key);
    if (!cached)
        return null;
    const { data, timestamp } = cached;
    if (Date.now() - timestamp > CACHE_TTL) {
        contentCache.delete(key);
        return null;
    }
    return data;
}
function setCachedContent(key, data) {
    contentCache.set(key, {
        data,
        timestamp: Date.now()
    });
    // Simple cache size management
    if (contentCache.size > 100) {
        const firstKey = contentCache.keys().next().value;
        if (firstKey) {
            contentCache.delete(firstKey);
        }
    }
}
/**
 * Generate hash for content caching
 */
function generateContentHash(source, style, language) {
    const content = JSON.stringify({
        url: source.url,
        transcript: source.transcript,
        description: source.description,
        style,
        language
    });
    // Simple hash function for caching
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
        const char = content.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash.toString(36);
}
/**
 * Create an enhanced fallback pitch with rich content for Shorts
 */
function createEnhancedFallbackPitch(source, targetStyle, targetLanguage, complexity) {
    const title = source.title || 'Untitled Content';
    const isShorts = (source.duration || 0) <= 60;
    const displayLanguage = getLanguageDisplayName(targetLanguage);
    // Check if we have video analysis data
    const hasVideoAnalysis = source.hasVideoAnalysis && source.videoAnalysis;
    const videoAnalysis = source.videoAnalysis;
    console.log('üé¨ Creating enhanced fallback with video analysis:', {
        hasVideoAnalysis,
        charactersCount: videoAnalysis?.characters?.length || 0,
        scenesCount: videoAnalysis?.sceneBreakdown?.length || 0,
        title
    });
    // If we have video analysis, use it to create a content-specific pitch
    if (hasVideoAnalysis && videoAnalysis && displayLanguage === 'Traditional Chinese') {
        const characters = videoAnalysis.characters || [];
        const scenes = videoAnalysis.sceneBreakdown || [];
        const transcript = videoAnalysis.generatedTranscript || '';
        // Determine content type from title and transcript
        const isProductAnalysis = title.includes('Áî¢ÂìÅ') || title.includes('‰∫ûÈ¶¨ÈÅú') || title.includes('Âà©ÊΩ§') || transcript.includes('Áî¢ÂìÅ');
        const isLifePhilosophy = title.includes('‰∫∫Áîü') || title.includes('ÊôÇÈñì') || transcript.includes('‰∫∫Áîü') || transcript.includes('ÊôÇÈñì');
        const isComedy = title.includes('üòÇ') || title.includes('Â§™ÊâØ') || title.includes('ÁàÜÁ¨ë');
        if (isProductAnalysis) {
            return `„ÄêÈõªÂïÜÊè≠ÂØÜ„Äë${title.substring(0, 30)}...

üé¨ ÊïÖ‰∫ãÊ¶ÇÂøµÔºö
‰∏Ä‰ΩçË≥áÊ∑±ÈõªÂïÜÂàÜÊûêÂ∏´ÈÄèÈÅéÂØ¶ÈöõÊï∏ÊìöÂàÜÊûêÔºåÊè≠Èú≤Á∂≤Ë∑ØÁÜ±Èä∑Áî¢ÂìÅËÉåÂæåÁöÑÂà©ÊΩ§ÁßòÂØÜ„ÄÇ

ËßíËâ≤Ë®≠ÂÆöÔºö
- ‰∏ªËßíÔºö${characters[0]?.description || 'Â∞àÊ•≠ÈõªÂïÜÂàÜÊûêÂ∏´'}
- ÁâπË≥™ÔºöÂñÑÊñºÊï∏ÊìöÂàÜÊûêÔºåËÉΩÂ∞áË§áÈõúË≥áË®äÁ∞°ÂåñË™™Êòé
- ÁõÆÊ®ôÔºöÂπ´Âä©ÂâµÊ•≠ËÄÖ‰∫ÜËß£ÁúüÂØ¶ÁöÑÈõªÂïÜÁîüÊÖã

Â†¥ÊôØÊû∂ÊßãÔºö${scenes.length > 0 ? `
${scenes.slice(0, 3).map((scene, i) => `${i + 1}. ${scene.description}`).join('\n')}` : `
1. ÈñãÂ†¥ÔºöÂ±ïÁ§∫ÁÜ±Èä∑Áî¢ÂìÅÂàóË°®
2. ÂàÜÊûêÔºöË©≥Á¥∞ÊãÜËß£ÊàêÊú¨ËàáÂîÆÂÉπ
3. ÁµêË´ñÔºöÁµ¶Âá∫ÂØ¶Áî®Âª∫Ë≠∞`}

Ê†∏ÂøÉÊ¥ûÂØüÔºö
ÈÄèÈÅéÁúüÂØ¶Êï∏ÊìöËÆìËßÄÁúæ‰∫ÜËß£ÈõªÂïÜÁî¢Ê•≠ÁöÑÈÅã‰ΩúÊ®°ÂºèÔºåÂπ´Âä©ÊúâÂøóÂâµÊ•≠ËÄÖÂÅöÂá∫ÊòéÊô∫Ê±∫Á≠ñ„ÄÇ

Ë¶ñË¶∫ÂëàÁèæÔºö
- Êï∏ÊìöÂúñË°®ÂãïÁï´Â±ïÁ§∫
- Áî¢ÂìÅÊàêÊú¨ÂàÜËß£Ë™™Êòé
- Ê∏ÖÊô∞ÁöÑÁµêË´ñÂíåÂª∫Ë≠∞`;
        }
        if (isLifePhilosophy) {
            return `„Äê‰∫∫ÁîüÊÄùËÄÉ„Äë${title.substring(0, 30)}...

üé¨ ÊïÖ‰∫ãÊ¶ÇÂøµÔºö
ÈÄèÈÅéÁç®ÁâπÁöÑË¶ñËßíÈáçÊñ∞ÂØ©Ë¶ñÊôÇÈñìËàá‰∫∫ÁîüÁöÑÈóú‰øÇÔºåÂ∏∂Áµ¶ËßÄÁúæÊ∑±ÂàªÁöÑÂèçÊÄù„ÄÇ

ËßíËâ≤Ë®≠ÂÆöÔºö
- ÊïòËø∞ËÄÖÔºö${characters[0]?.description || 'Ê∑±ÊÄùÁöÑËßÄÂØüËÄÖ'}
- ÁâπË≥™ÔºöÂñÑÊñºÂì≤Â≠∏ÊÄùËæ®ÔºåËÉΩÂ∞áÊäΩË±°Ê¶ÇÂøµÂÖ∑Ë±°Âåñ
- ‰ΩøÂëΩÔºöÂºïÂ∞éËßÄÁúæÊÄùËÄÉÁîüÂëΩÁöÑÊú¨Ë≥™

ÂÖßÂÆπÁµêÊßãÔºö${scenes.length > 0 ? `
${scenes.slice(0, 3).map((scene, i) => `${i + 1}. ${scene.description}`).join('\n')}` : `
1. ÂºïÂÖ•ÔºöÊèêÂá∫Áôº‰∫∫Ê∑±ÁúÅÁöÑÂïèÈ°å
2. Â±ïÈñãÔºöÁî®Ë¶ñË¶∫ÂåñÊñπÂºèÂëàÁèæÊ¶ÇÂøµ
3. ÊòáËèØÔºöÁµ¶Âá∫ÊÄùËÄÉÁöÑÊñπÂêë`}

Ê†∏ÂøÉÂÉπÂÄºÔºö
ËÆìËßÄÁúæÈáçÊñ∞ÊÄùËÄÉÊôÇÈñìÁöÑÁèçË≤¥Ôºå‰ª•ÂèäÂ¶Ç‰ΩïÊõ¥ÊúâÊÑèÁæ©Âú∞Â∫¶ÈÅéÊØè‰∏ÄÂ§©„ÄÇ

ÊÉÖÊÑüÂÖ±È≥¥Ôºö
ÈÄèÈÅéÁ∞°ÂñÆ‰ΩÜÊ∑±ÂàªÁöÑÊØîÂñªÔºåËß∏ÂãïËßÄÁúæÂÖßÂøÉÂ∞çÁîüÂëΩÊÑèÁæ©ÁöÑÊÄùËÄÉ„ÄÇ`;
        }
        if (isComedy) {
            return `„ÄêÁàÜÁ¨ëÁôºÁèæ„Äë${title.substring(0, 30)}...

üé¨ ÊïÖ‰∫ãÊ¶ÇÂøµÔºö
‰∏ªËßíÊÑèÂ§ñÁôºÁèæÁîüÊ¥ª‰∏≠‰ª§‰∫∫ÊçßËÖπÁöÑÂ∑ßÂêàÊàñÁèæË±°ÔºåËàáËßÄÁúæÂàÜ‰∫´ÈÄôÂÄãÊúâË∂£ÁöÑÁôºÁèæ„ÄÇ

ËßíËâ≤Ë®≠ÂÆöÔºö
- ÁôºÁèæËÄÖÔºö${characters[0]?.description || 'ÂπΩÈªòÁöÑËßÄÂØüÂÆ∂'}
- ÁâπË≥™ÔºöÂñÑÊñºÁôºÁèæÁîüÊ¥ªË∂£‰∫ãÔºåË°®ÈÅîÁîüÂãïÊúâË∂£
- È≠ÖÂäõÔºöËÉΩÂ∞áÂπ≥Âá°‰∫ãÁâ©ËÆäÂæóÂºï‰∫∫ÁôºÁ¨ë

Â†¥ÊôØÂ±ïÈñãÔºö${scenes.length > 0 ? `
${scenes.slice(0, 3).map((scene, i) => `${i + 1}. ${scene.description}`).join('\n')}` : `
1. Ë®≠ÁΩÆÔºöÊó•Â∏∏Â†¥ÊôØ‰∏≠ÁöÑÊÑèÂ§ñÁôºÁèæ
2. Â∞çÊØîÔºöÂ±ïÁ§∫‰ª§‰∫∫È©öË®ùÁöÑÁõ∏‰ººÊÄß
3. ÂèçÊáâÔºö‰∏ªËßíÂíåËßÄÁúæÁöÑÁàÜÁ¨ëÊôÇÂàª`}

Â®õÊ®ÇÊïàÊûúÔºö
ÈÄèÈÅéÂá∫‰∫∫ÊÑèÊñôÁöÑÂ∞çÊØîÂíåÂ∑ßÂêàÔºåÂâµÈÄ†ËÆì‰∫∫Âøç‰∏ç‰ΩèÂàÜ‰∫´ÁöÑÊ≠°Ê®ÇÊôÇÂàª„ÄÇ

ÁóÖÊØíÊΩõÂäõÔºö
ÈÅ©ÂêàÂºïÁôºË®éË´ñÂíåÊ®°‰ªøÔºåÂÆπÊòìÂú®Á§æÁæ§Â™íÈ´î‰∏äÂª£Ê≥õÂÇ≥Êí≠„ÄÇ`;
        }
        // General video analysis based fallback
        return `„ÄêÁ≤æÂΩ©ÂÖßÂÆπ„Äë${title.substring(0, 30)}...

üé¨ Âü∫ÊñºÂΩ±ÁâáÂàÜÊûêÔºö
Êú¨ÂΩ±ÁâáÂåÖÂê´${characters.length}ÂÄãËßíËâ≤Âíå${scenes.length}ÂÄãÂ†¥ÊôØÔºåÂ±ïÁèæ‰∫ÜË±êÂØåÁöÑÂÖßÂÆπÂ±§Ê¨°„ÄÇ

‰∏ªË¶ÅËßíËâ≤Ôºö${characters.length > 0 ? `
- ${characters[0].description}` : '\n- ÂÖßÂÆπ‰∏≠ÁöÑÈóúÈçµ‰∫∫Áâ©'}

Â†¥ÊôØÊ¶ÇË¶ΩÔºö${scenes.length > 0 ? `
${scenes.slice(0, 3).map((scene, i) => `${i + 1}. ${scene.description}`).join('\n')}` : `
1. ÈñãÂ†¥Â†¥ÊôØ
2. ‰∏ªË¶ÅÂÖßÂÆπÂ±ïÈñã
3. ÁµêÂ∞æÂ†¥ÊôØ`}

ÂÖßÂÆπÁâπËâ≤Ôºö
ÈÄèÈÅé${source.duration}ÁßíÁöÑÁ∑äÊπäÁØÄÂ•èÔºåÂÇ≥ÈÅîÊ†∏ÂøÉË®äÊÅØÁµ¶ÁõÆÊ®ôËßÄÁúæ„ÄÇ

ËßÄÁúãÂÉπÂÄºÔºö
ÁµêÂêàË¶ñË¶∫ÂëàÁèæÂíåÂÖßÂÆπÊ∑±Â∫¶ÔºåÁÇ∫ËßÄÁúæÂ∏∂‰æÜÊó¢ÊúâË∂£ÂèàÊúâÂÉπÂÄºÁöÑËßÄÁúãÈ´îÈ©ó„ÄÇ`;
    }
    // Enhanced Shorts-specific pitch templates (original logic)
    if (isShorts && (title.includes('üòÇ') || title.includes('Â§™ÊâØ'))) {
        if (displayLanguage === 'Traditional Chinese') {
            return `„ÄêÈ©öÂñúÁôºÁèæ„Äë„Äå${title}„Äç- ‰∏ÄÂÄãËÆì‰∫∫Âøç‰∏ç‰ΩèÁàÜÁ¨ëÁöÑÊÑèÂ§ñÁôºÁèæ

üé¨ ÊïÖ‰∫ãÊ¶ÇÂøµÔºö
ÈñãÂ†¥Ôºö‰∏ªËßíÁÑ°ÊÑèÈñìÁôºÁèæÂÖ©ÂÄãÁúã‰ººÂÆåÂÖ®‰∏çÁõ∏ÈóúÁöÑ‰∫ãÁâ©ÔºåÂçªÊúâËëó‰ª§‰∫∫ÈúáÈ©öÁöÑÁõ∏‰ººÊÄß

ËßíËâ≤Ë®≠ÂÆöÔºö
- ‰∏ªËßíÔºöÂ•ΩÂ•áÂøÉÊó∫ÁõõÁöÑÂπ¥Ëºï‰∫∫ÔºåÂñÑÊñºËßÄÂØüÁîüÊ¥ªÁ¥∞ÁØÄ
- ËÉåÊôØÔºöÁèæ‰ª£ÈÉΩÂ∏ÇÁîüÊ¥ªÂ†¥ÊôØÔºåÂÖÖÊªøÈ©öÂñúÁöÑÊó•Â∏∏Áû¨Èñì

Â†¥ÊôØÊèèËø∞Ôºö
1. ÈñãÈ†≠3ÁßíÔºöÂø´ÈÄüÂâ™Êé•Â±ïÁ§∫ÂÖ©ÂÄãÁâ©ÂìÅ/Â†¥ÊôØÁöÑÂ∞çÊØî
2. ‰∏≠ÊÆµÔºö‰∏ªËßíÁöÑË°®ÊÉÖËÆäÂåñ - ÂæûÂõ∞ÊÉëÂà∞È©öË®ùÂÜçÂà∞ÁàÜÁ¨ë
3. ÁµêÂ∞æÔºöÂä†ÂÖ•Ë∂£Âë≥ÊñáÂ≠óÁâπÊïàÂíåÈü≥ÊïàÔºåÂº∑ÂåñË¶ñË¶∫Ë°ùÊìä

Ë¶ñË¶∫È¢®Ê†ºÔºö
- ‰ΩøÁî®ÂàÜÂ±èÂ∞çÊØîÊâãÊ≥ïÔºåÁ™ÅÂá∫Áõ∏‰ººÊÄß
- Êòé‰∫ÆÁöÑËâ≤Ë™øÊê≠ÈÖçÔºåÁáüÈÄ†ËºïÈ¨ÜÊÑâÂø´Ê∞õÂõ¥
- Âø´ÁØÄÂ•èÂâ™Êé•ÈÖçÂêàÁØÄÂ•èÊÑüÂº∑ÁöÑËÉåÊôØÈü≥Ê®Ç
- ÊâãÊåÅÊîùÂΩ±È¢®Ê†ºÔºåÂ¢ûÂä†ÁúüÂØ¶ÊÑüÂíåË¶™ËøëÊÑü

ÊÉÖÊÑüÊõ≤Á∑öÔºö
Â•ΩÂ•á ‚Üí ÁñëÊÉë ‚Üí ÊÅçÁÑ∂Â§ßÊÇü ‚Üí Ê≠°Ê®ÇÂàÜ‰∫´
Êï¥ÂÄãÊïÖ‰∫ãÂú®11ÁßíÂÖßÂÆåÊàêÊÉÖÊÑüËΩâÊèõÔºåËÆìËßÄÁúæÁî¢ÁîüÂº∑ÁÉàÁöÑÂÖ±È≥¥ÂíåÂàÜ‰∫´ÊÖæÊúõ

ÁóÖÊØíÊΩúÂäõÔºö
- Âà©Áî®Ë¶ñË¶∫ÈåØË¶∫ÂíåË™çÁü•ÂÅèÂ∑ÆÂâµÈÄ†Ë©±È°åÊÄß
- ÈºìÂãµËßÄÁúæÂú®Ë©ïË´ñÂçÄÂàÜ‰∫´È°û‰ººÁôºÁèæ
- ÈÅ©ÂêàË£Ω‰ΩúÁ≥ªÂàóÂÖßÂÆπÔºåÂΩ¢ÊàêÊåÅÁ∫åÈóúÊ≥®`;
        }
    }
    return createFallbackPitch(source, targetStyle, targetLanguage);
}
/**
 * Create a structured fallback pitch when all AI generation fails
 */
function createStructuredFallbackPitch(source, content, complexity) {
    const title = source.title || 'Êú™ÂëΩÂêçÂÖßÂÆπ';
    const isShorts = (source.duration || 0) <= 60;
    const hasDescription = source.description && source.description.length > 20;
    // Check if we have video analysis data to create more specific content
    const hasVideoAnalysis = source.hasVideoAnalysis && source.videoAnalysis;
    const videoAnalysis = source.videoAnalysis;
    console.log('üé• Creating structured fallback with video analysis:', {
        hasVideoAnalysis,
        charactersCount: videoAnalysis?.characters?.length || 0,
        scenesCount: videoAnalysis?.sceneBreakdown?.length || 0,
        title
    });
    // Use video analysis data if available
    let coreStory = 'Âú®Áèæ‰ª£Á§æÊúÉÁöÑËÉåÊôØ‰∏ãÔºå‰∏Ä‰Ωç‰∏ªËßíÈù¢Â∞çÁùÄ‰∫∫ÁîüÁöÑÈáçË¶ÅËΩâÊäò„ÄÇ';
    let characterInfo = '28Ê≠≤Â∞àÊ•≠‰∫∫Â£´ÔºåÂÖßÂøÉÂ†ÖÂÆöÂçªÈù¢Â∞ç‰∏çÁ¢∫ÂÆöÊÄß';
    let personality = 'ÁêÜÊÄß‰∏≠Â∏∂ÊúâÊÉÖÊÑüÁöÑÁπ∞Á¥∞';
    let motivation = 'Â∞ãÊâæÂú®ËÆäÂåñ‰∏≠ÁöÑÂπ≥Ë°°ËàáÊñπÂêë';
    if (hasVideoAnalysis && videoAnalysis) {
        const characters = videoAnalysis.characters || [];
        const transcript = videoAnalysis.generatedTranscript || '';
        // Determine content type from title and transcript
        const isProductContent = title.includes('Áî¢ÂìÅ') || title.includes('‰∫ûÈ¶¨ÈÅú') || transcript.includes('Áî¢ÂìÅ');
        const isLifeContent = title.includes('‰∫∫Áîü') || title.includes('ÊôÇÈñì') || transcript.includes('‰∫∫Áîü');
        if (isProductContent) {
            coreStory = 'ÈÄèÈÅéÂ∞àÊ•≠ÂàÜÊûêÂ∏´ÁöÑË¶ñËßíÔºåÊ∑±ÂÖ•Êé¢Ë®éÂïÜÊ•≠‰∏ñÁïåÁöÑÈÅã‰ΩúÊ®°ÂºèÂíåÁ≠ñÁï•„ÄÇ';
            characterInfo = 'Ë≥áÊ∑±ÈõªÂïÜÂàÜÊûêÂ∏´ÔºåÊìÖÈï∑Êï∏ÊìöÂàÜÊûêÂíåÂ∏ÇÂ†¥Ê¥ûÂØü';
            personality = 'ÈÇèËºØÊ∏ÖÊô∞‰∏îÂñÑÊñºÁî®Êï∏ÊìöË™™ÊïÖ‰∫ã';
            motivation = 'Êè≠Èú≤ÂïÜÊ•≠ÁúüÁõ∏ÔºåÂπ´Âä©ÂâµÊ•≠ËÄÖÂÅöÂá∫ÊòéÊô∫Ê±∫Á≠ñ';
        }
        else if (isLifeContent) {
            coreStory = 'ÈÄöÈÅéÊ∑±ÂàªÁöÑÊÄùËÄÉÂíåÁç®ÁâπÁöÑË¶ñËßíÔºåÈáçÊñ∞ÂØ©Ë¶ñÊôÇÈñìËàá‰∫∫ÁîüÁöÑÈóú‰øÇ„ÄÇ';
            characterInfo = 'Âì≤Â≠∏ÊÄùËÄÉËÄÖÔºåÂñÑÊñºÂ∞áÊäΩË±°Ê¶ÇÂøµÂÖ∑Ë±°Âåñ';
            personality = 'ÁêÜÊÄßÊÄùËæ®‰∏îÂØåÊúâÂêåÁêÜÂøÉ';
            motivation = 'ÂºïÂ∞éËßÄÁúæÊÄùËÄÉÁîüÂëΩÁöÑÊú¨Ë≥™ÂíåÊÑèÁæ©';
        }
        else if (characters.length > 0) {
            const mainChar = characters[0];
            characterInfo = mainChar.description || 'ÂΩ±Áâá‰∏≠ÁöÑÈóúÈçµ‰∫∫Áâ©';
            coreStory = 'Âü∫ÊñºÁúüÂØ¶ÂΩ±ÁâáÂÖßÂÆπÔºåÂ±ïÁèæ‰∏ªËßíÁöÑÊàêÈï∑ËàáÁôºÁèæ‰πãÊóÖ„ÄÇ';
        }
    }
    // Create a more structured Traditional Chinese pitch
    const structuredPitch = `„ÄêÊïÖ‰∫ãÂ§ßÁ∂±„Äë${title}

üé• ÊïÖ‰∫ãÊ†∏ÂøÉÔºö
${coreStory}${hasDescription ? 'ÈÄèÈÅé ' + source.description?.substring(0, 100) + 'ÁöÑÊÉÖÁØÄË®≠ÂÆöÔºå' : ''}ÊïÖ‰∫ãÂ±ïÁèæ‰∫ÜÁç®ÁâπÁöÑË¶ñËßíÂíåÊ∑±Â∫¶ÂÖßÂÆπ„ÄÇ

ËßíËâ≤Ë®≠ÂÆöÔºö
- ‰∏ªËßíÔºö${characterInfo}
- ÊÄßÊ†ºÔºö${personality}
- ÂãïÊ©üÔºö${motivation}

Â†¥ÊôØÊû∂ÊßãÔºö${isShorts ? `
1. ÈñãÂ†¥Ôºà0-10ÁßíÔºâÔºöÂø´ÈÄüÂª∫Á´ãÊÉÖÂ¢ÉÂíå‰∏ªËßíÂΩ¢Ë±°
2. ËΩâÊäòÔºà10-40ÁßíÔºâÔºöÂ±ïÁ§∫Ê†∏ÂøÉË°ùÁ™ÅÂíåÊåëÊà∞
3. ÁµêÂ∞æÔºà40-60ÁßíÔºâÔºöÊÉÖÊÑüÈ´òÊΩÆÂíåÂïüÁôºÊÄßÁµêÂ∞æ` : `
1. ÂâçÂ∞éÔºöËÉåÊôØË®≠ÂÆöÂíåËßíËâ≤‰ªãÁ¥π
2. ÁôºÂ±ïÔºöÊïÖ‰∫ãË°ùÁ™ÅÂíåÊÉÖÁØÄÈÄ≤Â±ï
3. È´òÊΩÆÔºöÊúÄÂ§ßÊåëÊà∞ÂíåÊÉÖÊÑüË°ùÊìä
4. ÁµêÂ∞æÔºöËß£Ê±∫ÊñπÊ°àÂíåÊ∑±Â±§ÊÑèÁæ©`}

Ë¶ñË¶∫È¢®Ê†ºÔºö
- Áèæ‰ª£Á∞°Á¥ÑÈ¢®Ê†ºÔºåÂº∑Ë™ø‰∫∫Áâ©ÊÉÖÊÑüË°®ÈÅî
- Ê∏©ÊöñËâ≤Ë™øÊê≠ÈÖçÔºåÁáüÈÄ†Ë¶™ÂØÜÂÆâÂÖ®ÁöÑËßÄÂΩ±È´îÈ©ó
- ${isShorts ? 'Âø´ÁØÄÂ•èÂâ™Êé•ÔºåÁ∑äÊäìËßÄÁúæÊ≥®ÊÑèÂäõ' : 'Á©©ÂÆöÈè°È†≠Ë™ûË®ÄÔºåÁµ¶‰∫àËßÄÁúæÊôÇÈñìÊÄùËÄÉ'}

Ê†∏ÂøÉË®äÊÅØÔºö
ÈÄôÊòØ‰∏ÄÂÄãÈóúÊñºÂãáÊ∞£„ÄÅÊàêÈï∑ÂíåËá™ÊàëÊé¢Á¥¢ÁöÑÊïÖ‰∫ã„ÄÇÂú®‰∫∫ÁîüÁöÑÂçÅÂ≠óË∑ØÂè£ÔºåÊØèÂÄã‰∫∫ÈÉΩÈúÄË¶ÅÊâæÂà∞Â±¨ÊñºËá™Â∑±ÁöÑÁ≠îÊ°à„ÄÇ

ÁõÆÊ®ôËßÄÁúæÔºö
25-35Ê≠≤‰∏≠ÈùíÂπ¥Áæ§È´îÔºåÈóúÊ≥®ÂÄã‰∫∫ÊàêÈï∑ÂíåËÅ∑Â†¥ÁôºÂ±ïÁöÑËßÄÁúæ„ÄÇ`;
    return structuredPitch;
}
/**
 * Create a fallback pitch when AI processing fails
 */
function createFallbackPitch(source, targetStyle, targetLanguage) {
    const title = source.title || 'Untitled Content';
    const hasDescription = source.description && source.description.length > 20;
    const displayLanguage = getLanguageDisplayName(targetLanguage);
    // Language-specific fallback pitches
    const pitchTemplates = {
        'Traditional Chinese': (title, desc, style) => {
            if (hasDescription) {
                return `Êé¢Á¥¢„Äå${title}„ÄçËÉåÂæåÁöÑÊïÖ‰∫ã - ‰∏ÄÂÄãÂºï‰∫∫ÂÖ•ÂãùÁöÑÊïò‰∫ãÔºåÊé¢Ë®é${desc}${desc.length >= 100 ? '...' : ''}„ÄÇÈÄôÈÉ®${style}Â∞áÂÖßÂÆπ‰ª•Ë¶ñË¶∫ÂåñÁöÑÊñπÂºèÁîüÂãïÂëàÁèæ„ÄÇ`;
            }
            return `‰ª•ÂÖ®Êñ∞ÁöÑÊñπÂºèÈ´îÈ©ó„Äå${title}„Äç„ÄÇÈÄôÈÉ®${style}Â∞áÂéüÂßãÂÖßÂÆπËΩâÂåñÁÇ∫Âºï‰∫∫ÂÖ•ÂãùÁöÑË¶ñË¶∫ÊïÖ‰∫ãÔºåÊçïÊçâÊÇ®ÁöÑÊ≥®ÊÑèÂäõ‰∏¶ÊúâÊïàÂÇ≥ÈÅîË®äÊÅØ„ÄÇ`;
        },
        'Simplified Chinese': (title, desc, style) => {
            if (hasDescription) {
                return `Êé¢Á¥¢„Äå${title}„ÄçËÉåÂêéÁöÑÊïÖ‰∫ã - ‰∏Ä‰∏™Âºï‰∫∫ÂÖ•ËÉúÁöÑÂèô‰∫ãÔºåÊé¢ËÆ®${desc}${desc.length >= 100 ? '...' : ''}„ÄÇËøôÈÉ®${style}Â∞ÜÂÜÖÂÆπ‰ª•ËßÜËßâÂåñÁöÑÊñπÂºèÁîüÂä®ÂëàÁé∞„ÄÇ`;
            }
            return `‰ª•ÂÖ®Êñ∞ÁöÑÊñπÂºè‰ΩìÈ™å„Äå${title}„Äç„ÄÇËøôÈÉ®${style}Â∞ÜÂéüÂßãÂÜÖÂÆπËΩ¨Âåñ‰∏∫Âºï‰∫∫ÂÖ•ËÉúÁöÑËßÜËßâÊïÖ‰∫ãÔºåÊçïÊçâÊÇ®ÁöÑÊ≥®ÊÑèÂäõÂπ∂ÊúâÊïà‰º†Ëææ‰ø°ÊÅØ„ÄÇ`;
        },
        'English': (title, desc, style) => {
            if (hasDescription) {
                return `Discover the story behind "${title}" - a compelling narrative that explores ${desc}${desc.length >= 100 ? '...' : ''}. This ${style} brings the content to life in a visually engaging way.`;
            }
            return `Experience "${title}" in a new way. This ${style} transforms the original content into a compelling visual story that captures your attention and delivers the message effectively.`;
        }
    };
    const shortDesc = hasDescription ? (source.description || '').substring(0, 100).replace(/\s+/g, ' ').trim() : '';
    const styleText = targetStyle?.toLowerCase() || 'video';
    const pitchGenerator = pitchTemplates[displayLanguage] || pitchTemplates['English'];
    return pitchGenerator(title, shortDesc, styleText);
}
/**
 * Extract keywords from content for analysis
 */
function extractKeywordsFromContent(content) {
    if (!content || content.length < 10)
        return [];
    // Simple keyword extraction
    const words = content
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, ' ')
        .split(/\s+/)
        .filter(word => word.length > 3);
    // Count word frequency
    const wordCount = new Map();
    words.forEach(word => {
        wordCount.set(word, (wordCount.get(word) || 0) + 1);
    });
    // Return top 5 most frequent words
    return Array.from(wordCount.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([word]) => word);
}
/**
 * Extract YouTube transcript using the dedicated transcript library with improved error handling
 */
async function extractYouTubeTranscriptInternal(videoId, apiKey) {
    try {
        console.log(`Attempting transcript extraction for video: ${videoId}`);
        const transcriptResult = await (0, youtube_transcript_1.extractYouTubeTranscript)(videoId, apiKey);
        if (transcriptResult && transcriptResult.fullText && transcriptResult.fullText.trim().length > 0) {
            console.log(`Transcript extracted successfully (${transcriptResult.fullText.length} characters)`);
            return transcriptResult.fullText;
        }
        console.log('No usable transcript content available for this video');
        return undefined;
    }
    catch (error) {
        // This is expected for most videos due to OAuth requirements
        console.log('Transcript extraction failed (expected):', error instanceof Error ? error.message : error);
        return undefined;
    }
}
