/**
 * Simple JavaScript test runner for JSON parsing system
 * Tests the three-tier parsing strategy and AEGIS content
 */

// Import the necessary modules (simplified for Node.js execution)
const fs = require('fs');
const path = require('path');

// Define test data based on AEGIS firefighting content from logs
const AEGIS_FIREFIGHTING_CONTENT = {
  malformedJson: `\`\`\`json
{
 "scenario": "‰∏ÄÂ†¥Âä†Â∑ûÊ∑±Â±±ÈáéÁÅ´ËøÖÈÄüËîìÂª∂ÔºåÊîùÂΩ±Ê©üÂæûÁÅ´ËãóËøëÊôØÊãâÈÅ†ÔºåÂ±ïÁ§∫ÁÅ´ÁÑ∞ÂêûÂô¨Ê£ÆÊûóÁöÑÈß≠‰∫∫ÊôØË±°„ÄÇÂÇ≥Áµ±ÁöÑÊáâËÆäÊé™ÊñΩÁ∑©ÊÖ¢Â±ïÈñãÔºöÊ∂àÈò≤Â±ÄÊé•Âà∞Á∑äÊÄ•ÈÄöÁü•ÔºåË™øÂ∫¶‰∫∫ÂäõËàáÊ∂àÈò≤ËªäËâ±Èõ£Âú∞ÂæûÈÅ†ÊñπÈßõÂêëÁÅ´Â†¥ÔºåËÄåÁ©∫ÊãçÈè°È†≠ÂâáÁ™ÅÈ°Ø‰∫ÜË∑ØÈÄîÈÅôÈÅ†ËàáÁÅ´Âã¢ÁöÑÂ§±Êéß„ÄÇÂ∞±Âú®Âç±Ê©üÈÅîÂà∞È†ÇÈªûÊôÇÔºåÁï´Èù¢ÂàáÊèõÂà∞„ÄåAEGIS Autonomous Emergency Guardian Integrated System„ÄçÁöÑÂ≠óÊ®£„ÄÇÈö®ÂæåÔºåAEGISÁ≥ªÁµ±ÂïüÂãïÔºåÈÅçÂ∏ÉÊ∑±Â±±ÁöÑÊÑüÊ∏¨Âô®ÈñÉÁàçÁ¥ÖÂÖâÔºåÁ≤æÊ∫ñÂÅµÊ∏¨ÁÅ´Â†¥ÁöÑÊ∫´Â∫¶„ÄÅÈ¢®ÂêëËàáÈ¢®Âã¢Ôºå‰∏¶ÁôºÂá∫Âç≥ÊôÇÈ†êË≠¶„ÄÇÁ∑äÊé•ËëóÔºåÊï∏ÂçÅÊû∂AEGISÁÑ°‰∫∫Ê©üÁµÑÊàêÁöÑÈæêÂ§ßÊ©üÈöä‰ª•È©ö‰∫∫ÁöÑÈÄüÂ∫¶Ë°ùÂêëÁÅ´Â†¥ÔºåÈÅ†Ë∂ÖÂú∞Èù¢Ê∂àÈò≤ËªäÁöÑÈÄüÂ∫¶„ÄÇÁ¨¨‰∏ÄÊâπÁÑ°‰∫∫Ê©üÁ≤æÊ∫ñÊäµÈÅîÁÅ´Âã¢ÊúÄÁåõÁÉàÁöÑÂçÄÂüüÔºåÂú®È†êÂÆöÈñìÈöîÂºïÁàÜÁâπË£ΩÊªÖÁÅ´ÂΩàÔºåÁû¨ÈñìÂ£ìÂà∂ÁÅ´Âã¢„ÄÇÁ∑äÈö®ÂÖ∂ÂæåÔºåÁ¨¨‰∫åÊâπÁÑ°‰∫∫Ê©üÊîúÂ∏∂Â§ßÈáèËìÑÊ∞¥ÊäµÈÅîÔºåÂ∞çÊÆòÈ§òÁÅ´ÈªûÈÄ≤Ë°åÁ≤æÊ∫ñÊí≤ÊªÖÔºåÈò≤Ê≠¢ÁÅ´Âã¢Âæ©ÁáÉ„ÄÇÊúÄÁµÇÔºåÁï´Èù¢È°ØÁ§∫„ÄåDetected in Seconds. Extinguished with Precision.„ÄçÔºå‰∏¶‰ª•ÈªëÂ∫ïÁôΩÂ≠óÁöÑ„ÄåAEGIS„ÄçÊ®ôË™åÂÆåÁæéÊî∂Â∞æ„ÄÇ",
 "genre": "Cinematic",
 "mood": "Inspirational",`,
  
  referenceContent: `\`\`\`json
{
  "analysis": {
    "keyTopics": ["emergency response", "autonomous systems", "firefighting technology", "precision rescue"],
    "sentiment": "inspirational",
    "coreMessage": "AEGIS autonomous emergency response system revolutionizes wildfire suppression through precision technology",
    "targetAudience": "Technology enthusiasts and emergency services professionals"
  },
  "generatedPitch": "‰∏ÄÂ†¥Âä†Â∑ûÊ∑±Â±±ÈáéÁÅ´ËøÖÈÄüËîìÂª∂ÔºåÊîùÂΩ±Ê©üÂæûÁÅ´ËãóËøëÊôØÊãâÈÅ†ÔºåÂ±ïÁ§∫ÁÅ´ÁÑ∞ÂêûÂô¨Ê£ÆÊûóÁöÑÈß≠‰∫∫ÊôØË±°„ÄÇÂÇ≥Áµ±ÁöÑÊáâËÆäÊé™ÊñΩÁ∑©ÊÖ¢Â±ïÈñãÔºöÊ∂àÈò≤Â±ÄÊé•Âà∞Á∑äÊÄ•ÈÄöÁü•ÔºåË™øÂ∫¶‰∫∫ÂäõËàáÊ∂àÈò≤ËªäËâ±Èõ£Âú∞ÂæûÈÅ†ÊñπÈßõÂêëÁÅ´Â†¥ÔºåËÄåÁ©∫ÊãçÈè°È†≠ÂâáÁ™ÅÈ°Ø‰∫ÜË∑ØÈÄîÈÅôÈÅ†ËàáÁÅ´Âã¢ÁöÑÂ§±Êéß„ÄÇÂ∞±Âú®Âç±Ê©üÈÅîÂà∞È†ÇÈªûÊôÇÔºåÁï´Èù¢ÂàáÊèõÂà∞„ÄåAEGIS Autonomous Emergency Guardian Integrated System„ÄçÁöÑÂ≠óÊ®£„ÄÇÈö®ÂæåÔºåAEGISÁ≥ªÁµ±ÂïüÂãïÔºåÈÅçÂ∏ÉÊ∑±Â±±ÁöÑÊÑüÊ∏¨Âô®ÈñÉÁàçÁ¥ÖÂÖâÔºåÁ≤æÊ∫ñÂÅµÊ∏¨ÁÅ´Â†¥ÁöÑÊ∫´Â∫¶„ÄÅÈ¢®ÂêëËàáÈ¢®Âã¢Ôºå‰∏¶ÁôºÂá∫Âç≥ÊôÇÈ†êË≠¶„ÄÇÁ∑äÊé•ËëóÔºåÊï∏ÂçÅÊû∂AEGISÁÑ°‰∫∫Ê©üÁµÑÊàêÁöÑÈæêÂ§ßÊ©üÈöä‰ª•È©ö‰∫∫ÁöÑÈÄüÂ∫¶Ë°ùÂêëÁÅ´Â†¥ÔºåÈÅ†Ë∂ÖÂú∞Èù¢Ê∂àÈò≤ËªäÁöÑÈÄüÂ∫¶„ÄÇÁ¨¨‰∏ÄÊâπÁÑ°‰∫∫Ê©üÁ≤æÊ∫ñÊäµÈÅîÁÅ´Âã¢ÊúÄÁåõÁÉàÁöÑÂçÄÂüüÔºåÂú®È†êÂÆöÈñìÈöîÂºïÁàÜÁâπË£ΩÊªÖÁÅ´ÂΩàÔºåÁû¨ÈñìÂ£ìÂà∂ÁÅ´Âã¢„ÄÇÁ∑äÈö®ÂÖ∂ÂæåÔºåÁ¨¨‰∫åÊâπÁÑ°‰∫∫Ê©üÊîúÂ∏∂Â§ßÈáèËìÑÊ∞¥ÊäµÈÅîÔºåÂ∞çÊÆòÈ§òÁÅ´ÈªûÈÄ≤Ë°åÁ≤æÊ∫ñÊí≤ÊªÖÔºåÈò≤Ê≠¢ÁÅ´Âã¢Âæ©ÁáÉ„ÄÇÊúÄÁµÇÔºåÁï´Èù¢È°ØÁ§∫„ÄåDetected in Seconds. Extinguished with Precision.„ÄçÔºå‰∏¶‰ª•ÈªëÂ∫ïÁôΩÂ≠óÁöÑ„ÄåAEGIS„ÄçÊ®ôË™åÂÆåÁæéÊî∂Â∞æ„ÄÇ",
  "rationale": "This pitch showcases cutting-edge autonomous emergency response technology through dramatic visual storytelling"
}
\`\`\``
};

// Simplified three-tier parsing strategy implementation
function cleanJsonResponse(text) {
  if (!text || typeof text !== 'string') {
    return '{}';
  }
  
  console.log('Cleaning JSON response, original length:', text.length);
  
  // Remove markdown code blocks
  let cleaned = text.replace(/```json\s*/gi, '').replace(/```\s*/g, '').replace(/```/g, '').trim();
  
  // Remove any potential markdown artifacts
  cleaned = cleaned.replace(/^[\s\n]*```[\s\n]*/g, '').replace(/[\s\n]*```[\s\n]*$/g, '');
  
  // Find JSON object boundaries
  const jsonStart = cleaned.indexOf('{');
  const jsonEnd = cleaned.lastIndexOf('}');
  
  if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
    cleaned = cleaned.substring(jsonStart, jsonEnd + 1);
  }
  
  // Remove trailing commas
  cleaned = cleaned.replace(/,\s*([}\]])/g, '$1');
  
  return cleaned.trim();
}

function parseWithFallback(text) {
  console.log('üîÑ Starting three-tier parsing strategy...');
  
  // Tier 1: Strict parsing
  try {
    console.log('üìã Trying strict parsing...');
    const strictCleaned = cleanJsonResponse(text);
    const strictResult = JSON.parse(strictCleaned);
    console.log('‚úÖ Strict parsing successful');
    return { success: true, data: strictResult };
  } catch (e1) {
    console.warn('‚ö†Ô∏è Strict parsing failed:', e1.message);
  }
  
  // Tier 2: Main branch parsing
  try {
    console.log('üìã Trying main branch parsing...');
    const mainBranchCleaned = text.replace(/\`\`\`json|\`\`\`/g, '').trim();
    const mainBranchResult = JSON.parse(mainBranchCleaned);
    console.log('‚úÖ Main branch parsing successful');
    return { success: true, data: mainBranchResult };
  } catch (e2) {
    console.warn('‚ö†Ô∏è Main branch parsing failed:', e2.message);
  }
  
  // Tier 3: Intelligent repair
  try {
    console.log('üìã Trying intelligent repair...');
    let standardized = text.replace(/```json|```/g, '').trim();
    
    const jsonStart = standardized.indexOf('{');
    const jsonEnd = standardized.lastIndexOf('}');
    
    if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
      let repaired = standardized.substring(jsonStart, jsonEnd + 1);
      
      // Smart repair of common issues
      repaired = repaired
        .replace(/,\s*([}\]])/g, '$1')  // Remove trailing commas
        .replace(/\n/g, '\\n')          // Fix line breaks in strings
        .replace(/\r/g, '\\r')          // Fix carriage returns
        .replace(/\t/g, '\\t');         // Fix tabs
      
      const repairedResult = JSON.parse(repaired);
      console.log('‚úÖ Intelligent repair successful');
      return { success: true, data: repairedResult };
    }
  } catch (e3) {
    console.error('‚ùå All parsing methods failed:', e3.message);
  }
  
  return { 
    success: false, 
    error: {
      title: 'JSON Parsing Failed',
      message: 'Could not parse AI response with any method',
      actionable: 'Will use fallback content generation'
    }
  };
}

// Test execution
function runTests() {
  console.log('üß™ Enhanced JSON Parsing System - Comprehensive Test Suite');
  console.log('='.repeat(80));
  
  const results = [];
  let totalTests = 0;
  let passedTests = 0;
  
  // Test 1: Valid JSON (should pass strict parsing)
  console.log('\nüî¨ Test 1: Valid JSON - Strict Parsing');
  console.log('-'.repeat(40));
  totalTests++;
  const validJson = '{"test": "value", "number": 123}';
  const startTime1 = Date.now();
  const result1 = parseWithFallback(validJson);
  const time1 = Date.now() - startTime1;
  
  if (result1.success) {
    passedTests++;
    console.log(`‚úÖ PASS - Valid JSON parsed in ${time1}ms`);
    results.push({ test: 'Valid JSON', status: 'PASS', time: time1, strategy: 'strict' });
  } else {
    console.log(`‚ùå FAIL - Valid JSON failed: ${result1.error?.message}`);
    results.push({ test: 'Valid JSON', status: 'FAIL', time: time1, strategy: 'none', error: result1.error?.message });
  }
  
  // Test 2: AEGIS Content (reference format)
  console.log('\nüî¨ Test 2: AEGIS Reference Content');
  console.log('-'.repeat(40));
  totalTests++;
  const startTime2 = Date.now();
  const result2 = parseWithFallback(AEGIS_FIREFIGHTING_CONTENT.referenceContent);
  const time2 = Date.now() - startTime2;
  
  if (result2.success) {
    passedTests++;
    console.log(`‚úÖ PASS - AEGIS reference content parsed in ${time2}ms`);
    console.log('   Data keys:', Object.keys(result2.data));
    if (result2.data.generatedPitch) {
      console.log(`   Pitch length: ${result2.data.generatedPitch.length} characters`);
      console.log(`   Contains AEGIS: ${result2.data.generatedPitch.includes('AEGIS') ? 'Yes' : 'No'}`);
    }
    results.push({ test: 'AEGIS Reference Content', status: 'PASS', time: time2, strategy: 'tier-fallback' });
  } else {
    console.log(`‚ùå FAIL - AEGIS reference content failed: ${result2.error?.message}`);
    results.push({ test: 'AEGIS Reference Content', status: 'FAIL', time: time2, strategy: 'none', error: result2.error?.message });
  }
  
  // Test 3: AEGIS Malformed Content (the actual failing case)
  console.log('\nüî¨ Test 3: AEGIS Malformed Content (Critical Test)');
  console.log('-'.repeat(40));
  totalTests++;
  const startTime3 = Date.now();
  const result3 = parseWithFallback(AEGIS_FIREFIGHTING_CONTENT.malformedJson);
  const time3 = Date.now() - startTime3;
  
  if (result3.success) {
    passedTests++;
    console.log(`‚úÖ PASS - AEGIS malformed content repaired in ${time3}ms`);
    console.log('   Data keys:', Object.keys(result3.data));
    if (result3.data.scenario) {
      console.log(`   Scenario length: ${result3.data.scenario.length} characters`);
      console.log(`   Contains AEGIS: ${result3.data.scenario.includes('AEGIS') ? 'Yes' : 'No'}`);
    }
    results.push({ test: 'AEGIS Malformed Content', status: 'PASS', time: time3, strategy: 'intelligent-repair' });
  } else {
    console.log(`‚ùå FAIL - AEGIS malformed content failed: ${result3.error?.message}`);
    results.push({ test: 'AEGIS Malformed Content', status: 'FAIL', time: time3, strategy: 'none', error: result3.error?.message });
  }
  
  // Test 4: Main Branch Compatibility
  console.log('\nüî¨ Test 4: Main Branch Compatibility');
  console.log('-'.repeat(40));
  totalTests++;
  const mainBranchFormat = '```json\n{"test": "value", "trailing": "comma",}\n```';
  const startTime4 = Date.now();
  const result4 = parseWithFallback(mainBranchFormat);
  const time4 = Date.now() - startTime4;
  
  if (result4.success) {
    passedTests++;
    console.log(`‚úÖ PASS - Main branch format parsed in ${time4}ms`);
    results.push({ test: 'Main Branch Compatibility', status: 'PASS', time: time4, strategy: 'main-branch' });
  } else {
    console.log(`‚ùå FAIL - Main branch format failed: ${result4.error?.message}`);
    results.push({ test: 'Main Branch Compatibility', status: 'FAIL', time: time4, strategy: 'none', error: result4.error?.message });
  }
  
  // Test 5: Edge Case - Completely Invalid
  console.log('\nüî¨ Test 5: Edge Case - Invalid Content');
  console.log('-'.repeat(40));
  totalTests++;
  const invalidContent = 'This is definitely not JSON at all!!!';
  const startTime5 = Date.now();
  const result5 = parseWithFallback(invalidContent);
  const time5 = Date.now() - startTime5;
  
  if (!result5.success) {
    passedTests++; // Success means it correctly failed
    console.log(`‚úÖ PASS - Invalid content correctly rejected in ${time5}ms`);
    results.push({ test: 'Invalid Content Edge Case', status: 'PASS', time: time5, strategy: 'correctly-failed' });
  } else {
    console.log(`‚ùå FAIL - Invalid content incorrectly parsed: ${JSON.stringify(result5.data)}`);
    results.push({ test: 'Invalid Content Edge Case', status: 'FAIL', time: time5, strategy: 'false-positive', error: 'Should have failed but succeeded' });
  }
  
  // Summary
  console.log('\n' + '='.repeat(80));
  console.log('üìä COMPREHENSIVE TEST RESULTS SUMMARY');
  console.log('='.repeat(80));
  
  const successRate = (passedTests / totalTests) * 100;
  const totalTime = results.reduce((sum, r) => sum + r.time, 0);
  const avgTime = totalTime / totalTests;
  
  console.log(`\nüéØ Overall Results:`);
  console.log(`   Total Tests: ${totalTests}`);
  console.log(`   Passed: ${passedTests} ‚úÖ`);
  console.log(`   Failed: ${totalTests - passedTests} ‚ùå`);
  console.log(`   Success Rate: ${successRate.toFixed(2)}%`);
  console.log(`   Total Time: ${totalTime}ms`);
  console.log(`   Average Time: ${avgTime.toFixed(2)}ms`);
  
  console.log(`\nüìà Detailed Results:`);
  results.forEach((result, index) => {
    const status = result.status === 'PASS' ? 'üü¢' : 'üî¥';
    console.log(`   ${status} Test ${index + 1}: ${result.test}`);
    console.log(`      Strategy: ${result.strategy}, Time: ${result.time}ms`);
    if (result.error) {
      console.log(`      Error: ${result.error}`);
    }
  });
  
  // Critical Analysis
  console.log(`\nüîç Critical Analysis:`);
  
  // Check AEGIS tests specifically
  const aegisResults = results.filter(r => r.test.includes('AEGIS'));
  const aegisPassRate = (aegisResults.filter(r => r.status === 'PASS').length / aegisResults.length) * 100;
  
  console.log(`   AEGIS Firefighting Content: ${aegisPassRate.toFixed(0)}% success rate`);
  
  if (aegisPassRate === 100) {
    console.log(`   ‚úÖ AEGIS content parsing RESOLVED - Previously failing content now works!`);
  } else {
    console.log(`   ‚ö†Ô∏è AEGIS content parsing still has issues`);
  }
  
  // Check three-tier strategy effectiveness
  const strategies = {};
  results.forEach(r => {
    strategies[r.strategy] = (strategies[r.strategy] || 0) + 1;
  });
  
  console.log(`   Three-Tier Strategy Usage:`);
  Object.entries(strategies).forEach(([strategy, count]) => {
    console.log(`      ${strategy}: ${count} tests`);
  });
  
  // Performance analysis
  if (avgTime < 50) {
    console.log(`   ‚úÖ Excellent performance: ${avgTime.toFixed(2)}ms average`);
  } else if (avgTime < 200) {
    console.log(`   üü° Good performance: ${avgTime.toFixed(2)}ms average`);
  } else {
    console.log(`   üî¥ Performance needs improvement: ${avgTime.toFixed(2)}ms average`);
  }
  
  // Final verdict
  console.log(`\nüèÅ Final Verdict:`);
  if (successRate >= 90 && aegisPassRate >= 100) {
    console.log(`   üéâ EXCELLENT - System ready for production deployment`);
    console.log(`   ‚úÖ AEGIS firefighting content parsing issue RESOLVED`);
  } else if (successRate >= 80) {
    console.log(`   üü° GOOD - System performing well with minor issues`);
  } else {
    console.log(`   üî¥ NEEDS IMPROVEMENT - Critical issues must be addressed`);
  }
  
  console.log('='.repeat(80));
  
  return {
    totalTests,
    passedTests,
    successRate,
    totalTime,
    avgTime,
    results,
    aegisPassRate
  };
}

// Execute tests
if (require.main === module) {
  runTests();
}

module.exports = { runTests, parseWithFallback, cleanJsonResponse };