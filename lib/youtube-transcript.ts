/**
 * YouTube Transcript Extraction Library
 * 
 * This module provides functionality to extract transcripts/captions from YouTube videos
 * using the YouTube Data API v3 and caption endpoints.
 */

interface TranscriptSegment {
  text: string;
  start: number;
  duration: number;
}

interface TranscriptResult {
  segments: TranscriptSegment[];
  fullText: string;
  language: string;
  isAutoGenerated: boolean;
}

/**
 * Extract transcript from a YouTube video
 * 
 * @param videoId - YouTube video ID
 * @param apiKey - YouTube Data API key
 * @param preferredLanguage - Preferred language code (e.g., 'en', 'es')
 * @returns Promise<TranscriptResult | null>
 */
export async function extractYouTubeTranscript(
  videoId: string, 
  apiKey: string,
  preferredLanguage: string = 'en'
): Promise<TranscriptResult | null> {
  try {
    console.log(`Checking transcript availability for video: ${videoId}`);
    
    // Step 1: Get available captions for the video
    const captionsResponse = await fetch(
      `https://www.googleapis.com/youtube/v3/captions?videoId=${videoId}&key=${apiKey}&part=snippet`,
      {
        headers: {
          'Accept': 'application/json',
        }
      }
    );

    if (!captionsResponse.ok) {
      if (captionsResponse.status === 403) {
        console.log('YouTube API quota exceeded or access denied');
        return null;
      }
      throw new Error(`Failed to fetch captions list: ${captionsResponse.status}`);
    }

    const captionsData = await captionsResponse.json();
    const captions = captionsData.items || [];

    if (captions.length === 0) {
      console.log('No captions available for this video');
      return null;
    }

    console.log(`Found ${captions.length} caption track(s) available`);
    
    // Step 2: Find the best caption track
    const bestCaption = findBestCaptionTrack(captions, preferredLanguage);
    
    if (!bestCaption) {
      console.log('No suitable caption track found');
      return null;
    }

    console.log(`Best caption track: ${bestCaption.snippet.language} (${bestCaption.snippet.trackKind})`);

    // Step 3: Attempt to download the caption content
    // Note: This will fail for most videos due to OAuth requirement
    const captionContent = await downloadCaptionContent(bestCaption.id, apiKey);
    
    if (!captionContent) {
      console.log('Caption content download failed (OAuth required) - this is expected behavior');
      // Return metadata about available captions even if we can't download them
      return {
        segments: [],
        fullText: '',
        language: bestCaption.snippet.language,
        isAutoGenerated: bestCaption.snippet.trackKind === 'asr'
      };
    }

    // Step 4: Parse the caption content (unlikely to reach here)
    const transcript = parseCaptionContent(captionContent);
    
    return {
      segments: transcript.segments,
      fullText: transcript.fullText,
      language: bestCaption.snippet.language,
      isAutoGenerated: bestCaption.snippet.trackKind === 'asr'
    };

  } catch (error) {
    console.log('YouTube transcript extraction failed:', error instanceof Error ? error.message : error);
    return null;
  }
}

/**
 * Find the best caption track based on language preference
 */
function findBestCaptionTrack(captions: any[], preferredLanguage: string) {
  // Priority order:
  // 1. Manual captions in preferred language
  // 2. Auto-generated captions in preferred language  
  // 3. Manual captions in English
  // 4. Auto-generated captions in English
  // 5. Any manual captions
  // 6. Any auto-generated captions

  const priorities = [
    (cap: any) => cap.snippet.language === preferredLanguage && cap.snippet.trackKind !== 'asr',
    (cap: any) => cap.snippet.language === preferredLanguage && cap.snippet.trackKind === 'asr',
    (cap: any) => cap.snippet.language === 'en' && cap.snippet.trackKind !== 'asr',
    (cap: any) => cap.snippet.language === 'en' && cap.snippet.trackKind === 'asr',
    (cap: any) => cap.snippet.trackKind !== 'asr',
    (cap: any) => cap.snippet.trackKind === 'asr'
  ];

  for (const priority of priorities) {
    const match = captions.find(priority);
    if (match) return match;
  }

  return captions[0]; // Fallback to first available
}

/**
 * Download caption content from YouTube
 * Note: YouTube Data API v3 caption download requires OAuth 2.0 authentication,
 * not just an API key. This function will fail with 401 for most videos.
 * We'll implement a fallback approach that doesn't rely on caption downloads.
 */
async function downloadCaptionContent(captionId: string, apiKey: string): Promise<string | null> {
  try {
    console.warn('Attempting caption download (likely to fail due to OAuth requirement)');
    const response = await fetch(
      `https://www.googleapis.com/youtube/v3/captions/${captionId}?key=${apiKey}&tfmt=srv3`,
      {
        headers: {
          'Accept': 'application/xml, text/xml',
        }
      }
    );

    if (!response.ok) {
      if (response.status === 401) {
        console.log('Caption download requires OAuth 2.0 authentication (expected failure)');
        return null;
      }
      throw new Error(`Failed to download caption: ${response.status}`);
    }

    return await response.text();
  } catch (error) {
    console.log('Caption download failed (expected for most videos):', error instanceof Error ? error.message : error);
    return null;
  }
}

/**
 * Parse XML caption content into structured transcript
 */
function parseCaptionContent(xmlContent: string): { segments: TranscriptSegment[], fullText: string } {
  const segments: TranscriptSegment[] = [];
  
  try {
    // Simple XML parsing for srv3 format
    // In production, consider using a proper XML parser
    const textMatches = xmlContent.match(/<text[^>]*>([^<]*)<\/text>/g) || [];
    
    let fullText = '';
    
    for (const match of textMatches) {
      const startMatch = match.match(/start="([^"]*)"/) || ['', '0'];
      const durMatch = match.match(/dur="([^"]*)"/) || ['', '0'];
      const textMatch = match.match(/>([^<]*)</) || ['', ''];
      
      const start = parseFloat(startMatch[1]);
      const duration = parseFloat(durMatch[1]);
      const text = decodeXMLEntities(textMatch[1].trim());
      
      if (text) {
        segments.push({
          text,
          start,
          duration
        });
        
        fullText += text + ' ';
      }
    }
    
    return {
      segments,
      fullText: fullText.trim()
    };
    
  } catch (error) {
    console.error('Error parsing caption content:', error);
    return { segments: [], fullText: '' };
  }
}

/**
 * Decode XML entities in caption text
 */
function decodeXMLEntities(text: string): string {
  const entities: { [key: string]: string } = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&apos;': "'"
  };
  
  return text.replace(/&[#\w]+;/g, (entity) => {
    return entities[entity] || entity;
  });
}

/**
 * Enhanced metadata-based content extraction
 * When transcript is not available, we extract meaningful information from video metadata
 */
export async function extractVideoInsightsFromMetadata(
  videoId: string,
  apiKey: string
): Promise<{ title: string; description: string; insights: string } | null> {
  try {
    console.log(`Extracting enhanced metadata for video: ${videoId}`);
    
    const response = await fetch(
      `https://www.googleapis.com/youtube/v3/videos?id=${videoId}&key=${apiKey}&part=snippet,contentDetails,statistics`,
      {
        headers: {
          'Accept': 'application/json',
        }
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch video metadata: ${response.status}`);
    }

    const data = await response.json();
    const video = data.items?.[0];
    
    if (!video) {
      return null;
    }

    const snippet = video.snippet;
    const stats = video.statistics;
    const details = video.contentDetails;
    
    // Extract meaningful insights from available metadata
    const insights = generateVideoInsights({
      title: snippet.title,
      description: snippet.description,
      tags: snippet.tags || [],
      categoryId: snippet.categoryId,
      publishedAt: snippet.publishedAt,
      channelTitle: snippet.channelTitle,
      viewCount: stats?.viewCount,
      likeCount: stats?.likeCount,
      commentCount: stats?.commentCount,
      duration: details?.duration
    });
    
    return {
      title: snippet.title,
      description: snippet.description,
      insights
    };
    
  } catch (error) {
    console.error('Enhanced metadata extraction failed:', error);
    return null;
  }
}

/**
 * Generate insights from video metadata when transcript is unavailable
 */
function generateVideoInsights(metadata: any): string {
  const insights: string[] = [];
  
  // Add contextual information
  if (metadata.channelTitle) {
    insights.push(`This video is from the channel: ${metadata.channelTitle}`);
  }
  
  if (metadata.publishedAt) {
    const publishDate = new Date(metadata.publishedAt).toLocaleDateString();
    insights.push(`Published on: ${publishDate}`);
  }
  
  if (metadata.tags && metadata.tags.length > 0) {
    const relevantTags = metadata.tags.slice(0, 5).join(', ');
    insights.push(`Key topics/tags: ${relevantTags}`);
  }
  
  if (metadata.viewCount) {
    const views = parseInt(metadata.viewCount);
    if (views > 1000000) {
      insights.push('This is a popular video with over 1 million views');
    } else if (views > 100000) {
      insights.push('This video has significant engagement with 100K+ views');
    }
  }
  
  if (metadata.duration) {
    // Parse ISO 8601 duration
    const match = metadata.duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (match) {
      const hours = parseInt(match[1] || '0');
      const minutes = parseInt(match[2] || '0');
      const seconds = parseInt(match[3] || '0');
      const totalMinutes = hours * 60 + minutes + Math.round(seconds / 60);
      
      if (totalMinutes > 60) {
        insights.push('This is a long-form content piece');
      } else if (totalMinutes < 5) {
        insights.push('This is short-form content');
      } else {
        insights.push('This is medium-length content');
      }
    }
  }
  
  return insights.length > 0 
    ? `\n\nVideo Context: ${insights.join('. ')}.`
    : '';
}

/**
 * Utility function to validate YouTube video accessibility
 */
export async function isYouTubeVideoAccessible(videoId: string, apiKey: string): Promise<boolean> {
  try {
    const response = await fetch(
      `https://www.googleapis.com/youtube/v3/videos?id=${videoId}&key=${apiKey}&part=status`
    );
    
    if (!response.ok) return false;
    
    const data = await response.json();
    const video = data.items?.[0];
    
    return video && video.status.uploadStatus === 'processed' && video.status.privacyStatus !== 'private';
  } catch {
    return false;
  }
}